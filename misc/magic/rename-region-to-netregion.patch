diff --git a/extract/ExtArray.c b/extract/ExtArray.c
index beb2b32..933816a 100644
--- a/extract/ExtArray.c
+++ b/extract/ExtArray.c
@@ -734,7 +734,7 @@ extArrayNodeName(np, ha, et1, et2)
  * The node associated with a tile can be determined in one of the
  * following ways:
  *
- *	(1) Look for a label on the list of the Region pointed to by the
+ *	(1) Look for a label on the list of the NetRegion pointed to by the
  *	    tile planes of 'et->et_use->cu_def'.  If no label was found,
  *	    then try (2).
  *
diff --git a/extract/ExtBasic.c b/extract/ExtBasic.c
index 87e1656..3db4ef4 100644
--- a/extract/ExtBasic.c
+++ b/extract/ExtBasic.c
@@ -173,7 +173,7 @@ extFoundFunc(tile, cxp)
  * file 'outFile'.
  *
  * Results:
- *	Returns a list of Region structs that comprise all
+ *	Returns a list of NetRegion structs that comprise all
  *	the nodes in 'def'.  It is the caller's responsibility
  *	to call ExtResetTile() and ExtFreeLabRegions() to restore
  *	the CellDef to its original state and to free the list
@@ -191,7 +191,7 @@ extFoundFunc(tile, cxp)
  *		device
  *
  * Interruptible in a limited sense.  We will still return a
- * Region list, but labels may not have been assigned, and
+ * NetRegion list, but labels may not have been assigned, and
  * nodes and fets may not have been output.
  *
  * ----------------------------------------------------------------------------
@@ -260,7 +260,7 @@ extBasic(def, outFile)
     /*
      * Build up a list of the electrical nodes (equipotentials)
      * for extOutputNodes() below.  For this, we definitely want
-     * to leave each tile pointing to its associated Region struct.
+     * to leave each tile pointing to its associated NetRegion struct.
      * Compute resistance and capacitance on the fly.
      * Use a special-purpose version of ExtFindRegions for speed.
      */
@@ -1858,13 +1858,13 @@ extOutputDevices(def, transList, outFile)
 
 	/* Mark with reg and process each perimeter segment */
 	arg.fra_uninit = (ClientData) extTransRec.tr_gatenode;
-	arg.fra_region = (Region *) reg;
+	arg.fra_region = (NetRegion *) reg;
 	arg.fra_each = extTransTileFunc;
 	ntiles = ExtFindNeighbors(reg->treg_tile, arg.fra_pNum, &arg);
 
 	/* Re-mark with extTransRec.tr_gatenode */
 	arg.fra_uninit = (ClientData) reg;
-	arg.fra_region = (Region *) extTransRec.tr_gatenode;
+	arg.fra_region = (NetRegion *) extTransRec.tr_gatenode;
 	arg.fra_each = (int (*)()) NULL;
 	(void) ExtFindNeighbors(reg->treg_tile, arg.fra_pNum, &arg);
 
@@ -2157,7 +2157,7 @@ extOutputDevices(def, transList, outFile)
 		    /* Mark with reg and process each perimeter segment */
 
 		    arg.fra_uninit = (ClientData) extTransRec.tr_gatenode;
-		    arg.fra_region = (Region *) reg;
+		    arg.fra_region = (NetRegion *) reg;
 		    arg.fra_each = extAnnularTileFunc;
 
 		    (void) ExtFindNeighbors(reg->treg_tile, arg.fra_pNum, &arg);
@@ -2177,7 +2177,7 @@ extOutputDevices(def, transList, outFile)
 		    /* Re-mark with extTransRec.tr_gatenode */
 
 		    arg.fra_uninit = (ClientData) reg;
-		    arg.fra_region = (Region *) extTransRec.tr_gatenode;
+		    arg.fra_region = (NetRegion *) extTransRec.tr_gatenode;
 		    arg.fra_each = (int (*)()) NULL;
 		    (void) ExtFindNeighbors(reg->treg_tile, arg.fra_pNum, &arg);
 
@@ -2239,7 +2239,7 @@ extOutputDevices(def, transList, outFile)
 		    /* Mark with reg and process each perimeter segment */
 
 		    arg.fra_uninit = (ClientData) extTransRec.tr_gatenode;
-		    arg.fra_region = (Region *) reg;
+		    arg.fra_region = (NetRegion *) reg;
 		    if (isAnnular)
 		        arg.fra_each = extAnnularTileFunc;
 		    else
@@ -2275,7 +2275,7 @@ extOutputDevices(def, transList, outFile)
 		    /* Re-mark with extTransRec.tr_gatenode */
 
 		    arg.fra_uninit = (ClientData) reg;
-		    arg.fra_region = (Region *) extTransRec.tr_gatenode;
+		    arg.fra_region = (NetRegion *) extTransRec.tr_gatenode;
 		    arg.fra_each = (int (*)()) NULL;
 		    (void) ExtFindNeighbors(reg->treg_tile, arg.fra_pNum, &arg);
 		}
@@ -2377,7 +2377,7 @@ extOutputDevices(def, transList, outFile)
 			/* Mark with reg and process each perimeter segment */
 
 			arg.fra_uninit = (ClientData) extTransRec.tr_gatenode;
-			arg.fra_region = (Region *) reg;
+			arg.fra_region = (NetRegion *) reg;
 			arg.fra_each = extAnnularTileFunc;
 			(void) ExtFindNeighbors(reg->treg_tile, arg.fra_pNum, &arg);
 
@@ -2394,7 +2394,7 @@ extOutputDevices(def, transList, outFile)
 			/* Re-mark with extTransRec.tr_gatenode */
 
 			arg.fra_uninit = (ClientData) reg;
-			arg.fra_region = (Region *) extTransRec.tr_gatenode;
+			arg.fra_region = (NetRegion *) extTransRec.tr_gatenode;
 			arg.fra_each = (int (*)()) NULL;
 			(void) ExtFindNeighbors(reg->treg_tile, arg.fra_pNum, &arg);
 		    }
@@ -3892,7 +3892,7 @@ extSetNodeNum(reg, plane, tile)
  * ----------------------------------------------------------------------------
  */
 
-Region *
+NetRegion *
 extTransFirst(tile, arg)
     Tile *tile;
     FindRegion *arg;
@@ -3913,8 +3913,8 @@ extTransFirst(tile, arg)
 
     /* Prepend it to the region list */
     reg->treg_next = (TransRegion *) arg->fra_region;
-    arg->fra_region = (Region *) reg;
-    return ((Region *) reg);
+    arg->fra_region = (NetRegion *) reg;
+    return ((NetRegion *) reg);
 }
 
     /*ARGSUSED*/
@@ -3997,7 +3997,7 @@ extFindNodes(def, clipArea, subonly)
 	extNodeStack = StackNew(64);
 
     arg.fra_def = def;
-    arg.fra_region = (Region *) NULL;
+    arg.fra_region = (NetRegion *) NULL;
 
     SigDisableInterrupts();
 
@@ -4243,7 +4243,7 @@ extNodeAreaFunc(tile, arg)
 
     /* Prepend the new node to the region list */
     reg->nreg_next = (NodeRegion *) arg->fra_region;
-    arg->fra_region = (Region *) reg;
+    arg->fra_region = (NetRegion *) reg;
 
     /* Used by substrate generating routine */
     if (tile == NULL) return 1;
diff --git a/extract/ExtCell.c b/extract/ExtCell.c
index 8925718..1a2e597 100644
--- a/extract/ExtCell.c
+++ b/extract/ExtCell.c
@@ -248,7 +248,7 @@ extFileOpen(def, file, mode, doLocal, prealfile)
  * a cell on the plane representing the substrate to determine if the area is
  * the default substrate or an isolated region.  If an isolated region, it
  * must be painted with a tile type so that the extraction code can tag the
- * tiles with a Region and assign it a node.  This code creates the substrate
+ * tiles with a NetRegion and assign it a node.  This code creates the substrate
  * paint in the isolated regions for the duration of the extration, then
  * reverts back to the original plane afterward.
  *
diff --git a/extract/ExtHard.c b/extract/ExtHard.c
index 4aeab5d..28ef61c 100644
--- a/extract/ExtHard.c
+++ b/extract/ExtHard.c
@@ -70,7 +70,7 @@ bool extHardSetLabel();
  * ----------------------------------------------------------------------------
  */
 
-Region *
+NetRegion *
 extLabFirst(tile, arg)
     Tile *tile;
     FindRegion *arg;
@@ -85,8 +85,8 @@ extLabFirst(tile, arg)
 
     /* Prepend it to the region list */
     reg->treg_next = (TransRegion *) arg->fra_region;
-    arg->fra_region = (Region *) reg;
-    return ((Region *) reg);
+    arg->fra_region = (NetRegion *) reg;
+    return ((NetRegion *) reg);
 }
 
     /*ARGSUSED*/
@@ -211,7 +211,7 @@ extHardProc(scx, arg)
 	 * If labels are being generated automatically on this pass,
 	 * we don't bother to assign labels to geometry.  Instead, we
 	 * construct a new label based on the lower-leftmost tile in
-	 * the Region labRegList.
+	 * the NetRegion labRegList.
 	 */
 	if (arg->hw_autogen)
 	{
@@ -300,7 +300,7 @@ extHardSetLabel(scx, reg, arg)
 				 * coordinates in the def scx->scx_use->cu_def
 				 * up to root coordinates.
 				 */
-    TransRegion *reg;		/* Region with a label list */
+    TransRegion *reg;		/* NetRegion with a label list */
     HardWay *arg;		/* We will set arg->hw_label if a node
 				 * label is found on the label list of 'reg'.
 				 */
@@ -414,7 +414,7 @@ extHardGenerateLabel(scx, reg, arg)
 				 * generated label's coordinates up to
 				 * root coordinates.
 				 */
-    TransRegion *reg;		/* Region whose treg_ll and treg_pnum we use
+    TransRegion *reg;		/* NetRegion whose treg_ll and treg_pnum we use
 				 * to generate a new label name.
 				 */
     HardWay *arg;		/* We set arg->hw_label to the new label */
@@ -493,7 +493,7 @@ extHardFreeAll(def, tReg)
     arg.fra_connectsTo = ExtCurStyle->exts_nodeConn;
     arg.fra_def = def;
     arg.fra_each = (int (*)()) NULL;
-    arg.fra_region = (Region *) extUnInit;
+    arg.fra_region = (NetRegion *) extUnInit;
 
     for (reg = tReg; reg; reg = reg->treg_next)
     {
diff --git a/extract/ExtHier.c b/extract/ExtHier.c
index 506f6e8..044b320 100644
--- a/extract/ExtHier.c
+++ b/extract/ExtHier.c
@@ -941,7 +941,7 @@ extHierNewNode(he)
  */
 
     /*ARGSUSED*/
-Region *
+NetRegion *
 extHierLabFirst(tile, arg)
     Tile *tile;
     FindRegion *arg;
@@ -955,9 +955,9 @@ extHierLabFirst(tile, arg)
 
     /* Prepend it to the region list */
     new->lreg_next = (LabRegion *) arg->fra_region;
-    arg->fra_region = (Region *) new;
+    arg->fra_region = (NetRegion *) new;
 
-    return ((Region *) new);
+    return ((NetRegion *) new);
 }
 
     /*ARGSUSED*/
diff --git a/extract/ExtRegion.c b/extract/ExtRegion.c
index 362e159..ad5d4cd 100644
--- a/extract/ExtRegion.c
+++ b/extract/ExtRegion.c
@@ -46,11 +46,11 @@ static char rcsid[] __attribute__ ((unused)) = "$Header: /usr/cvsroot/magic-8.0/
  * Two procedures are supplied by the caller, 'first' and 'each'.
  *
  * The function 'first' must be non-NULL.  It is called for each tile
- * tile found in the region.  It must return a pointer to a Region
- * struct (or one of the client forms of a Region struct; see the
+ * tile found in the region.  It must return a pointer to a NetRegion
+ * struct (or one of the client forms of a NetRegion struct; see the
  * comments in extractInt.h).
  *
- *	Region *
+ *	NetRegion *
  *	(*first)(tile, arg)
  *	    Tile *tile;		/# Tile is on plane arg->fra_pNum #/
  *	    FindRegion *arg;
@@ -69,13 +69,13 @@ static char rcsid[] __attribute__ ((unused)) = "$Header: /usr/cvsroot/magic-8.0/
  *
  * Results:
  *	Returns a pointer to the first element in the linked list
- *	of Region structures for this CellDef.  The Region structs
- *	may in fact contain more than the basic Region struct; this
+ *	of NetRegion structures for this CellDef.  The NetRegion structs
+ *	may in fact contain more than the basic NetRegion struct; this
  *	will depend on what the function 'first' allocates.
  *
  * Side effects:
  *	Each non-space tile has its ti_client field left pointing
- *	to a Region structure that describes the region that tile
+ *	to a NetRegion structure that describes the region that tile
  *	belongs to.
  *
  * Non-interruptible.  It is the caller's responsibility to check
@@ -84,7 +84,7 @@ static char rcsid[] __attribute__ ((unused)) = "$Header: /usr/cvsroot/magic-8.0/
  * ----------------------------------------------------------------------------
  */
 
-Region *
+NetRegion *
 ExtFindRegions(def, area, mask, connectsTo, uninit, first, each)
     CellDef *def;		/* Cell definition being searched */
     Rect *area;			/* Area to search initially for tiles */
@@ -104,7 +104,7 @@ ExtFindRegions(def, area, mask, connectsTo, uninit, first, each)
     ClientData uninit;		/* Contents of a ti_client field indicating
 				 * that the tile has not yet been visited.
 				 */
-    Region * (*first)();	/* Applied to first tile in region */
+    NetRegion * (*first)();	/* Applied to first tile in region */
     int (*each)();		/* Applied to each tile in region */
 {
     FindRegion arg;
@@ -116,7 +116,7 @@ ExtFindRegions(def, area, mask, connectsTo, uninit, first, each)
     arg.fra_uninit = uninit;
     arg.fra_first = first;
     arg.fra_each = each;
-    arg.fra_region = (Region *) NULL;
+    arg.fra_region = (NetRegion *) NULL;
 
     /* Make sure temp_subsnode is NULL */
     temp_subsnode = NULL;
@@ -140,7 +140,7 @@ ExtFindRegions(def, area, mask, connectsTo, uninit, first, each)
  * equal to arg->fra_uninit are visited.
  *
  * We call 'fra_first' to allocate a new region struct for it, and then
- * prepend it to the Region list (Region *) arg->fra_clientData.  We
+ * prepend it to the NetRegion list (NetRegion *) arg->fra_clientData.  We
  * then call ExtFindNeighbors to trace out recursively all the remaining
  * tiles in the region.
  *
@@ -148,7 +148,7 @@ ExtFindRegions(def, area, mask, connectsTo, uninit, first, each)
  *	Always returns 0, to cause DBSrPaintClient to continue its search.
  *
  * Side effects:
- *	Allocates a new Region struct if the tile has not yet been visited.
+ *	Allocates a new NetRegion struct if the tile has not yet been visited.
  *	See also the comments for ExtFindNeighbors.
  *
  * ----------------------------------------------------------------------------
@@ -425,7 +425,7 @@ ExtLabelOneRegion(def, connTo, reg)
  *
  * Side effects:
  *	All the non-space tiles in the CellDef have their ti_client
- *	fields set back to uninitialized.  Does not free the Region
+ *	fields set back to uninitialized.  Does not free the NetRegion
  *	structs that these tiles point to; that must be done by
  *	ExtFreeRegions, ExtFreeLabRegions, or ExtFreeHierLabRegions.
  *
@@ -470,9 +470,9 @@ ExtResetTiles(def, resetTo)
 
 void
 ExtFreeRegions(regList)
-    Region *regList;	/* List of regions to be freed */
+    NetRegion *regList;	/* List of regions to be freed */
 {
-    Region *reg;
+    NetRegion *reg;
 
     for (reg = regList; reg; reg = reg->reg_next)
 	freeMagic((char *) reg);
@@ -495,9 +495,9 @@ ExtFreeLabRegions(regList)
 
 void
 ExtFreeHierLabRegions(regList)
-    Region *regList;	/* List of regions to be freed */
+    NetRegion *regList;	/* List of regions to be freed */
 {
-    Region *reg;
+    NetRegion *reg;
     LabelList *ll;
 
     for (reg = regList; reg; reg = reg->reg_next)
diff --git a/extract/ExtSubtree.c b/extract/ExtSubtree.c
index 692ed32..8a8bec9 100644
--- a/extract/ExtSubtree.c
+++ b/extract/ExtSubtree.c
@@ -950,7 +950,7 @@ extSubstrateFunc(scx, ha)
  * The node associated with a tile can be determined in one of the
  * following ways:
  *
- *	(1) Look for a label on the list of the Region pointed to by the
+ *	(1) Look for a label on the list of the NetRegion pointed to by the
  *	    tile planes of the yank buffer.  If no label was found, then
  *	    try (2).
  *
diff --git a/extract/extractInt.h b/extract/extractInt.h
index b5f54f1..7b7cde3 100644
--- a/extract/extractInt.h
+++ b/extract/extractInt.h
@@ -132,7 +132,7 @@ typedef struct ll
  * The following are the structures built up by the various
  * clients of ExtFindRegions.  The general rule for these
  * structures is that their initial fields must be identical
- * to those in a Region, but subsequent fields are up to
+ * to those in a NetRegion, but subsequent fields are up to
  * the individual client.
  *
  * Regions marked as GENERIC are the types accepted by
@@ -140,8 +140,8 @@ typedef struct ll
  */
 
     /*
-     * GENERIC Region struct.
-     * All this provides is a pointer to the next Region.
+     * GENERIC NetRegion struct.
+     * All this provides is a pointer to the next NetRegion.
      * This is the type passed to functions like ExtFreeRegions,
      * and is the type returned by ExtFindRegions.  Clients should
      * cast pointers of this type to their own, client type.
@@ -149,7 +149,7 @@ typedef struct ll
 typedef struct reg
 {
     struct reg	*reg_next;	/* Next region in list */
-} Region;
+} NetRegion;
 
     /*
      * GENERIC region with labels.
@@ -253,9 +253,9 @@ typedef struct
 					  * field of a tile if it's not yet
 					  * been visited.
 					  */
-    Region	      *(*fra_first)();	 /* Function to init new region */
+    NetRegion	      *(*fra_first)();	 /* Function to init new region */
     int		       (*fra_each)();	 /* Function for each tile in region */
-    Region		*fra_region;	 /* Ptr to Region struct for current
+    NetRegion		*fra_region;	 /* Ptr to NetRegion struct for current
 					  * region.  May be set by fra_first
 					  * and used by fra_each.
 					  */
@@ -1027,16 +1027,16 @@ extern ClientData extUnInit;
 	STACKPUSH((ClientData)(pointertype)(pl | TT_SIDE), extNodeStack); \
 	STACKPUSH((ClientData)(pointertype)tp, extNodeStack)
 
-/* ------------------------- Region finding --------------------------- */
+/* ------------------------- NetRegion finding --------------------------- */
 
-extern Region *ExtFindRegions();
+extern NetRegion *ExtFindRegions();
 extern LabelList *ExtLabelRegions();
 
 /* Filter functions for ExtFindRegions() */
-extern Region *extTransFirst();		extern int extTransEach();
-extern Region *extResFirst();		extern int extResEach();
-extern Region *extNodeFirst();		extern int extNodeEach();
-extern Region *extHierLabFirst();	extern int extHierLabEach();
+extern NetRegion *extTransFirst();		extern int extTransEach();
+extern NetRegion *extResFirst();		extern int extResEach();
+extern NetRegion *extNodeFirst();		extern int extNodeEach();
+extern NetRegion *extHierLabFirst();	extern int extHierLabEach();
 
 extern Tile *extNodeToTile();
 
diff --git a/plot/plotPNM.c b/plot/plotPNM.c
index 82b6e74..7b62d40 100644
--- a/plot/plotPNM.c
+++ b/plot/plotPNM.c
@@ -823,7 +823,7 @@ PlotPNM(fileName, scx, layers, xMask, width)
 
     TxPrintf ("PNM image dimensions: %d x %d\n", im_x, im_y);
 #if 0
-    TxPrintf ("Region size: %d x %d\n", tile_xsize, tile_ysize);
+    TxPrintf ("NetRegion size: %d x %d\n", tile_xsize, tile_ysize);
     TxPrintf ("Pixels per region: %d\n", y_pixels);
     TxPrintf ("Scale: %g\n", scale);
     TxPrintf ("Antialiasing overlap: %d\n", scale_over_2);
diff --git a/readline/readline-4.3/text.c b/readline/readline-4.3/text.c
index 2f8335f..2df581b 100644
--- a/readline/readline-4.3/text.c
+++ b/readline/readline-4.3/text.c
@@ -1496,7 +1496,7 @@ rl_backward_char_search (count, key)
 
 /* **************************************************************** */
 /*								    */
-/*		   The Mark and the Region.			    */
+/*		   The Mark and the NetRegion.			    */
 /*								    */
 /* **************************************************************** */
 
diff --git a/resis/ResMain.c b/resis/ResMain.c
index abbba4e..45dfa19 100644
--- a/resis/ResMain.c
+++ b/resis/ResMain.c
@@ -38,7 +38,7 @@ resNode			*ResNodeQueue = NULL;	/* Pending nodes	  */
 resNode			*ResOriginNode = NULL;	/* node where R=0	  */
 resNode			*resCurrentNode;
 int			ResTileCount = 0;	/* Number of tiles rn_status */
-extern Region 		*ResFirst();
+extern NetRegion 		*ResFirst();
 extern Tile		*FindStartTile();
 extern int		ResEachTile();
 extern int		ResLaplaceTile();
diff --git a/resis/ResUtils.c b/resis/ResUtils.c
index c519eec..c8ccd6b 100644
--- a/resis/ResUtils.c
+++ b/resis/ResUtils.c
@@ -44,7 +44,7 @@ static char rcsid[] __attribute__ ((unused)) = "$Header: /usr/cvsroot/magic-8.0/
  * -------------------------------------------------------------------------
  */
 
-Region *
+NetRegion *
 ResFirst(tile, arg)
     Tile *tile;
     FindRegion *arg;
@@ -82,9 +82,9 @@ ResFirst(tile, arg)
 	reg->cp_contactTile = tile;
 	/* Prepend it to the region list */
 	reg->cp_nextcontact = (ResContactPoint *) arg->fra_region;
-	arg->fra_region = (Region *) reg;
+	arg->fra_region = (NetRegion *) reg;
     }
-    return((Region *) NULL);
+    return((NetRegion *) NULL);
 }
 
 /*
diff --git a/sim/SimExtract.c b/sim/SimExtract.c
index 06a06fd..05703c8 100644
--- a/sim/SimExtract.c
+++ b/sim/SimExtract.c
@@ -580,7 +580,7 @@ SimFindOneNode( sx, tile )
 
     arg.fra_pNum = DBPlane(type);
     arg.fra_uninit = (ClientData) extUnInit;
-    arg.fra_region = (Region *) reg;
+    arg.fra_region = (NetRegion *) reg;
     arg.fra_each = SimFindTxtor;
     (void) ExtFindNeighbors( tile, arg.fra_pNum, &arg );
 
@@ -601,7 +601,7 @@ SimFindOneNode( sx, tile )
 
 	arg.fra_pNum = DBPlane(loctype);
 	arg.fra_uninit = (ClientData) extUnInit;
-	arg.fra_region = (Region *) reg;
+	arg.fra_region = (NetRegion *) reg;
 	arg.fra_each = SimTransistorTile;
 	(void) ExtFindNeighbors( gateTile, arg.fra_pNum, &arg );
 
@@ -609,7 +609,7 @@ SimFindOneNode( sx, tile )
 	arg.fra_connectsTo = ExtCurStyle->exts_nodeConn;
 	arg.fra_pNum = DBPlane(type);
 	arg.fra_uninit = (ClientData) reg;
-	arg.fra_region = (Region *) extUnInit;
+	arg.fra_region = (NetRegion *) extUnInit;
 	arg.fra_each = (int (*)()) NULL;
 	(void) ExtFindNeighbors( tile, arg.fra_pNum, &arg );
 
@@ -640,12 +640,12 @@ SimFindOneNode( sx, tile )
 
 	arg.fra_pNum = DBPlane(loctype);
 	arg.fra_uninit = (ClientData) sdTile->ti_client;
-	arg.fra_region = (Region *) &ret;
+	arg.fra_region = (NetRegion *) &ret;
 	arg.fra_each = SimTransistorTile;
 	(void) ExtFindNeighbors( sdTile, arg.fra_pNum, &arg );
 
 	/* Unmark the transitor, since its not part of this region */
-	arg.fra_region = (Region *) arg.fra_uninit;
+	arg.fra_region = (NetRegion *) arg.fra_uninit;
 	arg.fra_uninit = (ClientData) &ret;
 	arg.fra_each = (int (*)()) NULL;
 	(void) ExtFindNeighbors( sdTile, arg.fra_pNum, &arg );
diff --git a/utils/netlist.h b/utils/netlist.h
index dab6300..f292319 100644
--- a/utils/netlist.h
+++ b/utils/netlist.h
@@ -48,7 +48,7 @@ typedef struct nlTermLoc
     struct chan		*nloc_chan;	/* Contains nloc_stem */
     struct pin		*nloc_pin;	/* Pin on nloc_chan boundary */
 
-    struct region	*nloc_region;	/* Region containing stem */
+    struct region	*nloc_region;	/* NetRegion containing stem */
     struct czone	*nloc_czone;	/* Range containing point */
     int			 nloc_stemcost;	/* Cost of stem	*/
     int			 nloc_flags;	/* Flags */
